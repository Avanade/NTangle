/*
 * This file is automatically generated; any changes will be lost. 
 */

namespace SqlServerSidecarDemo.Publisher.Data;

/// <summary>
/// Enables the Change Data Capture (CDC) <see cref="ContactCdc"/> entity (aggregate root) orchestration (database table '[Legacy].[Contact]').
/// </summary>
public partial interface IContactOrchestrator : IEntityOrchestrator<ContactCdc> { }

/// <summary>
/// Manages the Change Data Capture (CDC) <see cref="ContactCdc"/> entity (aggregate root) orchestration (database table '[Legacy].[Contact]').
/// </summary>
public partial class ContactOrchestrator : EntitySidecarOrchestrator<ContactCdc, ContactOrchestrator.ContactCdcEnvelopeCollection, ContactOrchestrator.ContactCdcEnvelope, ContactOrchestrator.ContactBatchTracker, ContactOrchestrator.ContactBatchTrackerMapper, string>, IContactOrchestrator
{
    private static readonly ContactCdcMapper _contactCdcMapper = new();
    private static readonly AddressCdcMapper _addressCdcMapper = new();

    /// <summary>
    /// Initializes a new instance of the <see cref="ContactOrchestrator"/> class.
    /// </summary>
    /// <param name="database">The primary <see cref="IDatabase"/>.</param>
    /// <param name="sidecarDatabase">The sidecar <see cref="ISidecarDatabase"/>.</param>
    /// <param name="eventPublisher">The <see cref="IEventPublisher"/>.</param>
    /// <param name="jsonSerializer">The <see cref="IJsonSerializer"/>.</param>
    /// <param name="settings">The <see cref="SettingsBase"/>.</param>
    /// <param name="logger">The <see cref="ILogger"/>.</param>
    /// <param name="idGen">The <see cref="IIdentifierGenerator{T}"/>.</param>
    public ContactOrchestrator(IDatabase database, ISidecarDatabase sidecarDatabase, IEventPublisher eventPublisher, IJsonSerializer jsonSerializer, SettingsBase settings, ILogger<ContactOrchestrator> logger, IIdentifierGenerator<string> idGen)
        : base(database, sidecarDatabase, eventPublisher, jsonSerializer, settings, logger, idGen) => ContactOrchestratorCtor();

    partial void ContactOrchestratorCtor(); // Enables additional functionality to be added to the constructor.

    /// <inheritdoc/>
    protected override string ExecuteStoredProcedureName => "[NTangle].[spContactBatchExecute]";

    /// <inheritdoc/>
    protected override string CompleteStoredProcedureName => "[NTangle].[spContactBatchComplete]";

    /// <inheritdoc/>
    protected override string IdentifierMappingStoredProcedureName => "[NTangle].[spIdentifierMappingCreate]";

    /// <inheritdoc/>
    protected override string ExecuteCdcSqlResourceName => "Resources.Generated.ContactExecuteBatch.sql";

    /// <inheritdoc/>
    protected override string TrackingStoredProcedureName => "[NTangle].[spContactBatchTracking]";

    /// <inheritdoc/>
    protected override async Task GetBatchEntityDataAsync(EntityOrchestratorResult<ContactCdcEnvelopeCollection, ContactCdcEnvelope> result, DatabaseCommand? databaseCommand = null, CancellationToken cancellationToken = default)
    {
        static void lsnSynchronizer(DatabaseRecord dr, ContactBatchTracker bt)
        {
            bt.ContactMinLsn = dr.GetValue<byte[]>("ContactMinLsn");
            bt.ContactMaxLsn = dr.GetValue<byte[]>("ContactMaxLsn");
            bt.AddressMinLsn = dr.GetValue<byte[]>("AddressMinLsn");
            bt.AddressMaxLsn = dr.GetValue<byte[]>("AddressMaxLsn");
        }

        var cColl = new ContactCdcEnvelopeCollection();

        await SelectQueryMultiSetAsync(result, databaseCommand, MultiSetArgs.Create(
            // Root table: '[Legacy].[Contact]'
            new MultiSetCollArgs<ContactCdcEnvelopeCollection, ContactCdcEnvelope>(_contactCdcMapper, __result => cColl = __result, stopOnNull: true),

            // Join table: '[Legacy].[Address]' (unique name 'Address')
            new MultiSetCollArgs<ContactCdc.AddressCdcCollection, ContactCdc.AddressCdc>(_addressCdcMapper, __result =>
            {
                foreach (var a in __result.GroupBy(x => new { x.AID }).Select(g => new { g.Key.AID, Coll = g.ToCollection<ContactCdc.AddressCdcCollection, ContactCdc.AddressCdc>() }))
                {
                    cColl.Where(x => x.AddressId == a.AID).ForEach(x => x.Address = a.Coll.FirstOrDefault());
                }
            })), lsnSynchronizer, cancellationToken).ConfigureAwait(false);

        result.Result.AddRange(cColl);
    }

    /// <inheritdoc/>
    protected override string EventSubject => "Legacy.Contact";

    /// <inheritdoc/>
    protected override EventSubjectFormat EventSubjectFormat => EventSubjectFormat.NameOnly;

    /// <inheritdoc/>
    protected override EventActionFormat EventActionFormat => EventActionFormat.PastTense;

    /// <inheritdoc/>
    protected override string? EventType => "Legacy.Contact";

    /// <inheritdoc/>
    protected override Uri? EventSource => new("/database/cdc/legacy/contact", UriKind.Relative);

    /// <inheritdoc/>
    protected override EventSourceFormat EventSourceFormat { get; } = EventSourceFormat.NameAndTableKey;

    /// <summary>
    /// Executes explicit orchestation for the specified keys bypassing CDC (Change Data Capture) and <see cref="BatchTracker"/>.
    /// </summary>
    /// <param name="contactKeys">The 'Contact' database primary keys (as defined by <see cref="ContactCdcMapper.DatabaseInfo"/>).</param>
    /// <param name="addressKeys">The 'Address' database primary keys (as defined by <see cref="AddressCdcMapper.DatabaseInfo"/>).</param>
    /// <param name="options">The <see cref="ExplicitOptions"/>.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/>.</param>
    /// <returns>The <see cref="EntityOrchestratorResult"/>.</returns>
    /// <remarks><b>Note:</b> Explicit orchestrations bypass CDC (Change Data Capture) therefore access to <i>physically deleted</i> data is unreliable especially with respect to any child tables as there is no means to walk back up the join hierarchy.
    /// Only a delete from the root table can be inferred by its current non-existence. Provide <paramref name="options"/> to control the underlying behavior.</remarks>
    public Task<EntityOrchestratorResult> ExecuteExplicitAsync(IEnumerable<CompositeKey>? contactKeys, IEnumerable<CompositeKey>? addressKeys = default, ExplicitOptions? options = null, CancellationToken cancellationToken = default) 
    {
        CheckAtLeastASingleKey(contactKeys, addressKeys);

        var cmd = Database.SqlFromResource("Resources.Generated.ContactExecuteExplicit.sql")
            .Param("ContactKeysList", CreateJsonForKeys(ContactCdcMapper.DatabaseInfo, contactKeys))
            .Param("AddressKeysList", CreateJsonForKeys(AddressCdcMapper.DatabaseInfo, addressKeys));

        return ExecuteExplicitAsync(cmd, options, cancellationToken);
    }

    /// <summary>
    /// Represents a <see cref="ContactCdc"/> envelope to append the required (additional) database properties.
    /// </summary>
    public class ContactCdcEnvelope : ContactCdc, IEntityEnvelope
    {
        /// <inheritdoc/>
        [JsonIgnore]
        public CdcOperationType DatabaseOperationType { get; set; }

        /// <inheritdoc/>
        [JsonIgnore]
        public byte[] DatabaseLsn { get; set; } = [];

        /// <inheritdoc/>
        [JsonIgnore]
        public string? DatabaseTrackingHash { get; set; }

        /// <inheritdoc/>
        [JsonIgnore]
        public bool IsDatabasePhysicallyDeleted { get; set; }
    }

    /// <summary>
    /// Represents a <see cref="ContactCdcEnvelope"/> collection.
    /// </summary>
    public class ContactCdcEnvelopeCollection : List<ContactCdcEnvelope> { }

    /// <summary>
    /// Represents a <see cref="ContactCdc"/> database mapper.
    /// </summary>
    public class ContactCdcMapper : IDatabaseMapper<ContactCdcEnvelope>, IDatabaseInfo
    {
        /// <inheritdoc/>
        public static DatabaseInfo DatabaseInfo => new("Legacy", "Contact", ["CID"]);

        /// <inheritdoc/>
        public ContactCdcEnvelope? MapFromDb(DatabaseRecord record, OperationTypes operationType) => new()
        {
            CID = record.GetValue<int>("CID"),
            Name = record.GetValue<string?>("Name"),
            Phone = record.GetValue<string?>("Phone"),
            Email = record.GetValue<string?>("Email"),
            Active = record.GetValue<bool?>("Active"),
            DontCallList = record.GetValue<bool?>("DontCallList"),
            AddressId = record.GetValue<int?>("AddressId"),
            AlternateContactId = record.GetValue<int?>("AlternateContactId"),
            UniqueId = record.GetValue<Guid>("UniqueId"),
            DatabaseOperationType = record.GetValue<CdcOperationType>(CdcOperationTypeColumnName),
            DatabaseLsn = record.GetValue<byte[]>(CdcLsnColumnName),
            IsDatabasePhysicallyDeleted = record.GetValue<bool>(IsPhysicallyDeletedColumnName)
        };

        /// <inheritdoc/>
        void IDatabaseMapper<ContactCdcEnvelope>.MapToDb(ContactCdcEnvelope? value, DatabaseParameterCollection parameters, OperationTypes operationType) => throw new NotImplementedException();
    }

    /// <summary>
    /// Represents a <see cref="AddressCdc"/> database mapper.
    /// </summary>
    public class AddressCdcMapper : IDatabaseMapper<ContactCdc.AddressCdc>, IDatabaseInfo
    {
        /// <inheritdoc/>
        public static DatabaseInfo DatabaseInfo => new("Legacy", "Address", ["AID"]);

        /// <inheritdoc/>
        public ContactCdc.AddressCdc? MapFromDb(DatabaseRecord record, OperationTypes operationType) => new()
        {
            AID = record.GetValue<int>("AID"),
            Street1 = record.GetValue<string?>("Street1"),
            Street2 = record.GetValue<string?>("Street2"),
            AlternateAddressId = record.GetValue<int?>("AlternateAddressId")
        };

        /// <inheritdoc/>
        void IDatabaseMapper<ContactCdc.AddressCdc>.MapToDb(ContactCdc.AddressCdc? value, DatabaseParameterCollection parameters, OperationTypes operationType) => throw new NotImplementedException();
    }

    /// <summary>
    /// Represents the 'Contact'-specific <see cref="BatchTracker"/>.
    /// </summary>
    public class ContactBatchTracker : BatchTracker
    {
        /// <summary>
        /// Gets or sets the 'Contact' minimum LSN (Log Sequence Number).
        /// </summary>
        public byte[]? ContactMinLsn { get; set; }

        /// <summary>
        /// Gets or sets the 'Contact' maximum LSN (Log Sequence Number).
        /// </summary>
        public byte[]? ContactMaxLsn { get; set; }

        /// <summary>
        /// Gets or sets the 'Address' minimum LSN (Log Sequence Number).
        /// </summary>
        public byte[]? AddressMinLsn { get; set; }

        /// <summary>
        /// Gets or sets the 'Address' maximum LSN (Log Sequence Number).
        /// </summary>
        public byte[]? AddressMaxLsn { get; set; }
    }

    /// <summary>
    /// Represents the <see cref="ContactBatchTracker"/> database mapper.
    /// </summary>
    public class ContactBatchTrackerMapper : DatabaseMapperEx<ContactBatchTracker>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ContactBatchTrackerMapper"/> class.
        /// </summary>
        public ContactBatchTrackerMapper() => InheritMapper(BatchTrackerMapper.Default);

        /// <inheritdoc/>
        protected override void OnMapFromDb(DatabaseRecord record, ContactBatchTracker value, OperationTypes operationType)
        {
            value.ContactMinLsn = record.GetValue<byte[]?>("ContactMinLsn");
            value.ContactMaxLsn = record.GetValue<byte[]?>("ContactMaxLsn");
            value.AddressMinLsn = record.GetValue<byte[]?>("AddressMinLsn");
            value.AddressMaxLsn = record.GetValue<byte[]?>("AddressMaxLsn");
        }

        /// <inheritdoc/>
        protected override void OnMapToDb(ContactBatchTracker value, DatabaseParameterCollection parameters, OperationTypes operationType)
        {
            parameters.AddParameter("ContactMinLsn", value.ContactMinLsn, dbType: System.Data.DbType.Binary);
            parameters.AddParameter("ContactMaxLsn", value.ContactMaxLsn, dbType: System.Data.DbType.Binary);
            parameters.AddParameter("AddressMinLsn", value.AddressMinLsn, dbType: System.Data.DbType.Binary);
            parameters.AddParameter("AddressMaxLsn", value.AddressMaxLsn, dbType: System.Data.DbType.Binary);
        }
    }
}